/* makebiramp.hoc   sets up a triangular waveform for use as a command potential   assumes the following are known:   dt		time step*/// Easy mnemonics so I can set these in the interpreter// and then invoke simple() (just in case I forget the calling// syntax for mkramp(), or maybe only want to change one param).// My convention for constants is upper caseV0 = -80	// default for stdrun.hoc is -65 mVSLOPE = 0.2	// mv/msTR = 10000	// msobjref mycmd,mycmd1,mycmd2mycmd = new Vector()	// must create object outside procmycmd1 = new Vector()	// must create object outside procmycmd2 = new Vector()	// must create object outside proc/* Creates a "ramp" vector      _____ v1     /    / slopev0 /    tr arguments:   $1	v0	command at start of ramp	(mV)   $2	slope	dv/dt during ramp			(mV/ms)   $3	tr	duration of ramp			(ms)		note 1: v1 = v0 + slope*tr		note 2: at end of t0 + tr, vector.play will leave 			command at v1, but if this is played into 			dur2 of a SEClamp object, what really happens 			will depend on whether t enters dur3 */// I double the initial letter so these local variables won't // collide with global names that I may want to use laterproc mkbiramp() { local ii, vv0, sslope, ttr, vv1	vv0 = $1	sslope = $2	ttr = $3	vv1 = vv0 + sslope*ttr/2	mycmd1.indgen(vv0, vv1, dt*sslope)	mycmd2.indgen(vv0,vv1,dt*sslope) mycmd2.reverse() mycmd.resize(0) mycmd.append(mycmd1,mycmd2)}// I can invoke mkbiramp() with all 3 arguments,// or I can change a single "constant" (V0, SLOPE, or TR)// and then invoke simple() with no arguments.proc simple() {	mkbiramp(V0, SLOPE, TR)}proc vsimple() {	mkbiramp(vV0, vSLOPE, vTR)}