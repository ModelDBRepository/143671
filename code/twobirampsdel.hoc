/* make2biramps.hoc   sets up a triangular waveform for use as a command potential   assumes the following are known:   dt		time step*/// Easy mnemonics so I can set these in the interpreter// and then invoke simple() (just in case I forget the calling// syntax for mkramp(), or maybe only want to change one param).// My convention for constants is upper caseRSTRT1=0	SLOPE1 = 0.2	TR = 10000	// msRSTRT2=0	SLOPE2 = 0.1DEL = 1000	objref mycmd1,mycmd1a,mycmd1b,mycmd1c,mycmd1d,mycmd2,mycmd2a,mycmd2b,mycmd2c,mycmd2dmycmd1 = new Vector()	// must create object outside procmycmd1a = new Vector()	// must create object outside procmycmd1b = new Vector()	// must create object outside procmycmd1c = new Vector()	// must create object outside procmycmd1d = new Vector()	// must create object outside procmycmd2 = new Vector()	// must create object outside procmycmd2a = new Vector()	// must create object outside procmycmd2b = new Vector()	// must create object outside procmycmd2c = new Vector()	// must create object outside procmycmd2d = new Vector()	// must create object outside proc/* Creates a "ramp" vector      _____ v1     /    / slopev0 /    tr arguments:   $1	v0	command at start of ramp	(mV)   $2	slope	dv/dt during ramp			(mV/ms)   $3	tr	duration of ramp			(ms)     $4  del    hold period at start and end of ramp		note 1: v1 = v0 + slope*tr		note 2: at end of t0 + tr, vector.play will leave 			command at v1, but if this is played into 			dur2 of a SEClamp object, what really happens 			will depend on whether t enters dur3 */// I double the initial letter so these local variables won't // collide with global names that I may want to use laterproc mkbiramp1d() { local ii, vv0, sslope, ttr, vv1, ddel1	vv0 = $1	sslope = $2	ii=0	if (sslope<0) {	sslope *= -1	ii=1	}	ttr = $3	ddel1=$4	vv1 = vv0 + sslope*ttr/2	mycmd1a.resize(ddel1/dt)	mycmd1a.fill(vv0)	mycmd1b.indgen(vv0, vv1, dt*sslope)	mycmd1c.indgen(vv0,vv1,dt*sslope)	mycmd1d.resize(ddel1/dt)	mycmd1d.fill(vv0) mycmd1c.reverse() mycmd1.resize(0) mycmd1.append(mycmd1a,mycmd1b,mycmd1c,mycmd1d) if (ii==1) { mycmd1.sub(vv0) mycmd1.mul(-1) mycmd1.add(vv0)}}proc mkbiramp2d() { local ii, vv0, sslope, ttr, vv1, ddel1	vv0 = $1	sslope = $2	ii=0	if (sslope<0) {	sslope *= -1	ii=1	}	ttr = $3	ddel1=$4	vv1 = vv0 + sslope*ttr/2	mycmd2a.resize(ddel1/dt)	mycmd2a.fill(vv0)	mycmd2b.indgen(vv0, vv1, dt*sslope)	mycmd2c.indgen(vv0,vv1,dt*sslope)	mycmd2d.resize(ddel1/dt)	mycmd2d.fill(vv0) mycmd2c.reverse() mycmd2.resize(0) mycmd2.append(mycmd2a,mycmd2b,mycmd2c,mycmd2d) if (ii==1) { mycmd2.sub(vv0) mycmd2.mul(-1) mycmd2.add(vv0)}}// I can invoke mkbirampd() with all 4 arguments,// or I can change a single "constant" (V0, SLOPE, TR, or HOLD)// and then invoke simple2d() with no arguments.proc simple2del() {	mkbiramp1d(RSTRT1, SLOPE1, TR, HOLD)	mkbiramp2d(RSTRT2, SLOPE2, TR, HOLD)}